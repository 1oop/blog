+++
title = 'Kubernetes Intro'
date = 2024-01-03T13:30:43+08:00

+++

# Kubernetes简明介绍
![](Pasted%20image%2020231226173957.png)

## Kubernetes是什么？
>Kubernetes 也称为 k8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统。
>--Kubernetes官网介绍

> [!HINT] 为什么Kubernetes又叫k8s?
> 因为Kubernets单词太长，社区为了书写方便，便取单词的首位两个字母，并用在中用8表示中间省略的字母。

>后续内容中，除特殊地方外，统一称为K8s。

**k8s**如今在中大型互联网公司当中拥有相当广泛的使用群体，且已是**容器编排**领域的事实标准和规则制定者。从其大展拳脚的容器编排领域可以看出，k8s的流行归根于*Docker*所带来的*容器化*的浪潮，而容器化的流行则源自于微服务的兴起。

**容器技术**相关的技术出现得很早，但其早期因复杂的接口以及不够完善的安全性、隔离性、资源利用差等原因，一直处于很尴尬的境地。直到Docker的出现，它实现了统一的接口和标准化的容器格式，极大地简化了容器创建和部署，充分展现了容器的*轻量级*、*自包含*、*可移植*等优点。使其征服了广大开发及运维人员，超越*裸机*和*虚拟机*等开发部署模式，成为现代软件开发与部署的*新王*，而Docker也一度成为容器的代名词。

容器化浪潮的早期阶段，还是单体应用大行其道的时代，运维人员使自动化脚本或*Docker Compose*即可完成容器的管理和维护，只有极少数大公司可能需要对应的管理工具进行维护。但随着**微服务架构**的流行，容器应用的规模逐渐增加，管理和维护如此量级的容器就成了所有公司都必须面对的难题。

*Google*公司从零几年就开始管理大规模的Linux容器，并在其内部开发了一个名为*Borg*的系统用于管理这些容器。而**Kubernetes**则是Google根据自身容器管理经验以及Borg使用经验，开发的一个开源版本的容器编排工具，并捐赠给云原生计算基金会（**CNCF**）进行维护。k8s依仗其优秀的设计理念，背靠拥有顶尖技术开发人员的Google公司，一经开源便获得了广泛的关注。k8s凭借其活跃的社区氛围、丰富的功能集、优秀的扩展性，击败了同一领域的其他编排工具如 *Docker Swarm* 、*Mesos*，成为容器编排领域的事实标准。同时，k8s制定了一系列接口标准如**CNI**、**CSI**、**CRI**等，这些标准的定制让k8s的体系结构更加模块化，增强了可扩展性，也k8s生态系统更加丰富。
## k8s具体能做什么？
在实际生产环境中， 我们要保障服务正确地运行，就得要求容器应用运行正确的数量在可用的节点上。一旦出现某个节点或容器出现无法访问时，整个集群需要动态地调整，从其他可用节点启动对应数量的容器，以保证服务处于正确的状态。

而这些，就是K8s能够完成的事情。它为我们提供了一个可弹性运行分布式系统的框架，满足我们动态扩展、故障转移、部署模式等要求。同时，K8s还提供了非常强大的容器网络相关的功能，以至于有网友称Kubernetes为**Supernetes**。
### 从k8s官网上可以看的，k8s主要提供了以下功能：
* 自动化上线和回滚
* 服务发现和负载均衡
* 自我修复
* 存储编排
* Secret 和 配置管理
* 自动装箱
* 批量任务执行
* IPv4 和 IPv6双栈协议
* 水平扩缩
* 为扩展设计

K8s提供了很多类似于*PaaS*系统相关的功能，例如服务部署、扩展、负载均衡，允许用户集成他们的日志记录、监控和警报方案。但它有别于包罗万象的PaaS，它运行在容器级别而非硬件级别。它也不是单体式系统，几乎所有默认方案都是可选、可插拔的，在重要的地方保留了用户选择权，能有更高的灵活性。

### 不建议使用K8s的情况：
* 应用无法容器化：K8s作为一个容器管理系统，它专为管理和扩展容器化的应用程序而设计。
* 单体应用程序：部署维护K8s的工作量远大于收益。
* 无需更新的历史遗留程序：K8s作为现代化的容器编排工具，可能难以兼容遗留系统。
* 资源受限环境：K8s作为一个复杂的系统，会占用一定的资源使用量。

> 如果要在IoT等边缘计算场景下使用K8s，可以考虑以下项目：
> K3s
> KubeEdge
> MicroK8s
> K0s

## K8s是如何实现上述功能的？
K8s采用的是*声明式*的模式来进行应用管理。Google根据自身业务积累，将运行在生产中的应用程序，根据其特点进行了整合，并设计了大量K8s对象。而用户只需要使用这些实体来描述声明对集群的**期望状态**，K8s会根据这些声明来实例化并维护这些K8s对象实体。也就是说这些实体共同作用，表示了集群的**真实状态**。

> 声明式和命令式的区别类似于空调和电扇：
> 
> 空调属于"声明式"，我们只需要声明指定温度，空调内部系统就会调整各个组建的工作状态来维持这个温度。
> 声明式的优点是更接近自然语言易于理解和维护，缺点是实现复杂。
> 
> 电扇属于"命令式"，只能接受调大调小风速等具体命令，我们需要根据自己感受来调整风速大小。
> 命令式的优点是编码简单、细节清楚，缺点是维护性和可读性较差。
### K8s提供的常用对象有：
* 工作负载相关
	* Pod
	* Deployment
	* ReplicaSet
	* StatefulSet
	* DaemonSet
	* Job
	* CronJob
* 网络相关
	* Service
	* Ingress
	* Gateway
	* NetworkPolicy
> 注意：以上仅列出部分对象，详细列表可在官网查看。

一个完整的K8s系统是由很多组件组成，**Pod** 是可以在 K8s 中创建和管理的、最小的可部署的计算单元。在K8s运行过程中，组件**Crontroller Manager** 负责通过不断比对集群*真实状态*与*期望状态*，来发现状态差异。一旦发现差异存在，便生成Pod调度任务。而**Scheduler**则根据需要调度Pod的资源需求来选择可用节点(**Node**)。节点上的**kubelet**组件监听属于自己的Pod队列，并执行创建或删除Pod的管理操作，最终使系统状态达到预期。

>注：以上只是流程简述，实际过程中，有很多不同类型的控制器通过**API server**来相互协作，最终使系统达到预期。详细流程会在后续进行源码解读时进行分析。

K8s的组件：
* API server
* Crontroller Manager
* Scheduler
* etcd
* kubelet
* kube-proxy

## 项目略读

项目目录：
```bash
.
├── CHANGELOG
├── CHANGELOG.md -> CHANGELOG/README.md
├── CONTRIBUTING.md
├── LICENSE
├── LICENSES
├── Makefile -> build/root/Makefile  # 构建入口文件
├── OWNERS
├── OWNERS_ALIASES
├── README.md
├── SECURITY_CONTACTS
├── SUPPORT.md
├── api                                  
├── build                            # 构建相关的脚本
├── cluster
├── cmd                              # 组件可执行文件入口
├── code-of-conduct.md
├── docs
├── go.mod
├── go.sum
├── hack
├── logo
├── pkg                              # 具体实现
├── plugin                           # 插件目录
├── staging
├── test                             # 测试工具
├── third_party                      # 第三方工具或代码
└── vendor                           # 项目依赖
```

K8s项目最新版本(1.29)的代码统计：

```bash
===============================================================================
 Language            Files        Lines         Code     Comments       Blanks
===============================================================================
 Go                  10442      2901677      2280926       379714       241037
 JSON                  696       810827       810825            0            2
 YAML                 4629       253066       251123         1485          458
 Shell                 298        49655        31086        12350         6219
 Protocol Buffers       89        32007         8618        18555         4834
 PowerShell              6         3943         2892          749          302
 Makefile               27         1854          899          717          238
 Dockerfile             51         1369          396          768          205
 Autoconf               23         1114          995           92           27
 Python                  7          692          443          138          111
 SVG                     4          406          398            4            4
 Plain Text             22          269            0          221           48
 C                       3          153           89           47           17
 BASH                   10           53           17           24           12
 Batch                   1           21            2           17            2
 HTML                    3            3            3            0            0
-------------------------------------------------------------------------------
 Markdown              252        90092            0        72304        17788
 |- BASH                12          119           87           23            9
 |- Go                   3           23           14            5            4
 |- JSON                 1           22           22            0            0
 |- PowerShell           1           10            9            1            0
 |- Shell                6          228          178           17           33
 |- YAML                11          105          102            2            1
 (Total)                          90599          412        72352        17835
===============================================================================
 Total               16563      4147201      3388712       487185       271304
===============================================================================
```

>以上数据不包含vendor以及third_party目录的代码。

从统计数据可以看出，K8s的代码行数已经超过200万行，已超过Go语言(1.22版本)本身的代码行数为190+万行，从这个对比数据足以看出K8s项目的复杂度。所以在此就暂不展开源码部分的解析，后续单开一个系列记录源码学习。

## 一句话总结
Kubernetes是一个开源的集群容器管理系统，用户可以使用易于维护的声明式配置来管理集群容器。